// Generated by CoffeeScript 1.4.0
(function() {
  var CogSegment, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if ((_ref = window.Amoeba) == null) {
    window.Amoeba = {};
  }

  Amoeba.Cog = (function() {

    function Cog(size, numSegments, graphicsPaper) {
      this.size = size;
      this.numSegments = numSegments;
      this.graphicsPaper = graphicsPaper;
      this._createCogSegments = __bind(this._createCogSegments, this);

      this._pairsAroundCircle = __bind(this._pairsAroundCircle, this);

      this._pointsAroundCircle = __bind(this._pointsAroundCircle, this);

      this.showPoints = __bind(this.showPoints, this);

    }

    Cog.prototype.path = function(showTeeth) {
      var result, segment, segments, _i, _len;
      segments = this._createCogSegments(this.size, showTeeth, this.numSegments);
      result = null;
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (!(result != null)) {
          result = "M" + segment.bottomLeft.x + "," + segment.bottomLeft.y;
        }
        result += segment.path();
      }
      result += "z";
      return result;
    };

    Cog.prototype.showPoints = function() {
      var segment, segments, _i, _len, _results;
      segments = this._createCogSegments(this.size, true, this.numSegments);
      _results = [];
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        _results.push(segment.debugPoints(this.graphicsPaper));
      }
      return _results;
    };

    Cog.prototype._pointsAroundCircle = function(size, inset, numSegments, shift) {
      var angle, centerPoint, degrees, degreesShift, i, radius, result, _i;
      if (shift == null) {
        shift = 0;
      }
      centerPoint = new Amoeba.Point(size / 2, size / 2);
      radius = (size - (inset * 2)) / 2;
      degrees = 360 / numSegments;
      result = [];
      for (i = _i = 0; 0 <= numSegments ? _i <= numSegments : _i >= numSegments; i = 0 <= numSegments ? ++_i : --_i) {
        angle = i * degrees;
        degreesShift = degrees * 0.15;
        if (shift === -1) {
          angle -= degreesShift;
        } else if (shift === 1) {
          angle += degreesShift;
        }
        if (angle >= 360) {
          angle = angle - 360;
        } else if (angle < 0) {
          angle = 360 + angle;
        }
        result.push(Amoeba.Graphics.pointForAngle(angle, radius, centerPoint));
      }
      return result;
    };

    Cog.prototype._pairsAroundCircle = function(size, inset, numSegments, shifted) {
      var i, leftPoints, nextPoint, points, prevPoint, result, rightPoints, _i, _j, _len, _ref1;
      if (shifted == null) {
        shifted = false;
      }
      result = [];
      if (!shifted) {
        points = this._pointsAroundCircle(size, inset, numSegments);
        prevPoint = null;
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          nextPoint = points[_i];
          if ((prevPoint != null)) {
            result.push(new Amoeba.Pair(prevPoint, nextPoint));
          }
          prevPoint = nextPoint;
        }
      } else {
        leftPoints = this._pointsAroundCircle(size, inset, numSegments, -1);
        rightPoints = this._pointsAroundCircle(size, inset, numSegments, -1);
        for (i = _j = 0, _ref1 = leftPoints.length - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          result.push(new Amoeba.Pair(leftPoints[i], rightPoints[i + 1]));
        }
      }
      return result;
    };

    Cog.prototype._createCogSegments = function(size, showTeeth, numSegments) {
      var i, innerPoint, innerPoints, isTooth, newSegment, outerPoint, outerPoints, result, toothHeight, _i;
      result = [];
      toothHeight = 0;
      outerPoints = this._pairsAroundCircle(size, 0, numSegments, false);
      if (showTeeth) {
        toothHeight = outerPoints[0].left.distance(outerPoints[0].right) * 0.55;
      }
      innerPoints = this._pairsAroundCircle(size, toothHeight, numSegments, false);
      if ((outerPoints.length !== innerPoints.length) || (outerPoints.length !== numSegments)) {
        console.log("inner and outer points not right?");
      } else {
        isTooth = false;
        for (i = _i = 0; 0 <= numSegments ? _i < numSegments : _i > numSegments; i = 0 <= numSegments ? ++_i : --_i) {
          outerPoint = outerPoints[i];
          innerPoint = innerPoints[i];
          newSegment = new CogSegment(isTooth, size, toothHeight, outerPoint.left, outerPoint.right, innerPoint.left, innerPoint.right);
          result.push(newSegment);
          isTooth = !isTooth;
        }
      }
      return result;
    };

    Cog.prototype._alternateGear = function() {
      var a0, da, i, inRadius, inTeeth, insideOut, n, path, r0, r1, r2, r3;
      inRadius = 200;
      inTeeth = 32;
      insideOut = false;
      n = inTeeth;
      r2 = Math.abs(inRadius);
      r0 = r2 - 8;
      r1 = r2 + 8;
      if (insideOut) {
        r3 = r0;
        r0 = r1;
        r1 = r3;
        r3 = r2 + 20;
      } else {
        r3 = 20;
      }
      da = Math.PI / n;
      a0 = -Math.PI / 2 + (insideOut != null ? insideOut : Math.PI / {
        n: 0
      });
      i = -1;
      path = ["M", r0 * Math.cos(a0), ",", r0 * Math.sin(a0)];
      while (++i < n) {
        path.push("A", r0, ",", r0, " 0 0,1 ", r0 * Math.cos(a0 += da), ",", r0 * Math.sin(a0), "L", r2 * Math.cos(a0), ",", r2 * Math.sin(a0), "L", r1 * Math.cos(a0 += da / 3), ",", r1 * Math.sin(a0), "A", r1, ",", r1, " 0 0,1 ", r1 * Math.cos(a0 += da / 3), ",", r1 * Math.sin(a0), "L", r2 * Math.cos(a0 += da / 3), ",", r2 * Math.sin(a0), "L", r0 * Math.cos(a0), ",", r0 * Math.sin(a0));
      }
      path.push("M0,", -r3, "A", r3, ",", r3, " 0 0,0 0,", r3, "A", r3, ",", r3, " 0 0,0 0,", -r3, "Z");
      return path.join("");
    };

    return Cog;

  })();

  CogSegment = (function() {

    function CogSegment(isTooth, size, toothHeight, topLeft, topRight, bottomLeft, bottomRight) {
      this.isTooth = isTooth;
      this.size = size;
      this.toothHeight = toothHeight;
      this.topLeft = topLeft;
      this.topRight = topRight;
      this.bottomLeft = bottomLeft;
      this.bottomRight = bottomRight;
      this.outerRadius = this.size / 2;
      this.innerRadius = (this.size - (this.toothHeight * 2)) / 2;
    }

    CogSegment.prototype.toString = function() {
      return "(" + this.topLeft + ", " + this.topRight + ", " + this.bottomLeft + ", " + this.bottomRight + ")";
    };

    CogSegment.prototype.debugPoints = function(graphicsPaper) {
      if (this.isTooth) {
        graphicsPaper.addPoints([this.topLeft], 2, "black");
        graphicsPaper.addPoints([this.topRight], 2, "orange");
        graphicsPaper.addPoints([this.bottomLeft], 2, "black");
        return graphicsPaper.addPoints([this.bottomRight], 2, "orange");
      } else {
        graphicsPaper.addPoints([this.topLeft], 2, "red");
        graphicsPaper.addPoints([this.topRight], 2, "yellow");
        graphicsPaper.addPoints([this.bottomLeft], 2, "red");
        return graphicsPaper.addPoints([this.bottomRight], 2, "yellow");
      }
    };

    CogSegment.prototype.path = function() {
      var flag, result;
      result = "";
      if (this.isTooth) {
        result += "L" + this.topLeft.x + "," + this.topLeft.y;
        result += "A" + this.outerRadius + "," + this.outerRadius + ",0,0,1," + this.topRight.x + "," + this.topRight.y;
        result += "L" + this.bottomRight.x + "," + this.bottomRight.y;
      } else {
        flag = 1;
        if (this.toothHeight > 0) {
          flag = 0;
        }
        result += "A" + this.outerRadius + "," + this.outerRadius + ",0,0," + flag + "," + this.bottomRight.x + "," + this.bottomRight.y;
      }
      return result;
    };

    return CogSegment;

  })();

}).call(this);
